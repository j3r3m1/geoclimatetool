# -*- coding: utf-8 -*-

"""
/***************************************************************************
 GeoClimate Workflow
                                 A QGIS plugin
 This plugin execute the GeoClimate workflows
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-02-06
        copyright            : (C) 2023 by Jérémy Bernard
        email                : jeremy.bernard@zaclys.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jérémy Bernard'
__date__ = '2024-02-06'
__copyright__ = '(C) 2024 by Jérémy Bernard'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterField,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterMatrix,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterString,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterBoolean,
                       QgsRasterLayer,
                       QgsVectorLayer,
                       QgsProject,
                       QgsProcessingContext,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterFile,
                       QgsProcessingException,
                       QgsLayerTreeGroup,
                       QgsProcessingParameterExtent,
                       QgsCoordinateTransform,
                       QgsCoordinateReferenceSystem,
                       QgsGeometry)
from qgis.utils import iface
from pathlib import Path
from qgis.PyQt.QtGui import QIcon
import inspect
#import unidecode
from .functions.globalVariables import *
from .functions.otherFunctions import runProcess
import json
from urllib.request import urlretrieve
import glob

class GeoClimateProcessorAlgorithm(QgsProcessingAlgorithm):
    """ Create a GeoClimate config file and run the corresponding workflow    
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    # Input variables
    # Input dataset used for the workflow
    INPUT_DATASET = "INPUT_DATASET"
    # Tick if you want to estimate missing OSM building height
    ESTIMATED_HEIGHT = "ESTIMATED_HEIGHT"
    # Tick if you want to produce a LCZ map"
    LCZ_CALC = "LCZ_CALC"
    # Tick if you want to produce the UTRF classification
    UTRF_CALC = "UTRF_CALC"
    # Tick if you want to calculate WRF inputs
    WRF_INPUTS = "WRF_INPUTS"
    # Tick if you want to calculate TEB inputs
    TEB_INPUTS = "TEB_INPUTS"
    # Quick calculation of the SVF
    SVF_SIMPLIFIED = "SVF_SIMPLIFIED"
    # Location to process
    LOCATION = "LOCATION"
    # Extent if extent is used instead of location
    EXTENT = "EXTENT"
    # Warning: seems to not work in any folder of the temp...
    OUTPUT_DIRECTORY = "OUTPUT_DIRECTORY"
    
    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        
        # We add the input parameters
        self.addParameter(
            QgsProcessingParameterEnum(
                self.INPUT_DATASET, 
                self.tr('What data do you want to use as input'),
                list(SRID.keys()),
                defaultValue=0,
                optional = False))
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.ESTIMATED_HEIGHT,
                self.tr('Tick if you want to estimate missing OSM building height'),
                defaultValue = True)) 
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LCZ_CALC,
                self.tr('Tick if you want to produce a LCZ map"'),
                defaultValue = False)) 
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.UTRF_CALC,
                self.tr('Tick if you want to produce the UTRF classification'),
                defaultValue = False)) 
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.WRF_INPUTS,
                self.tr('Tick if you want to calculate the WRF spatial inputs'),
                defaultValue = False)) 
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.TEB_INPUTS,
                self.tr('Tick if you want to calculate the TEB spatial inputs'),
                defaultValue = False)) 
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.SVF_SIMPLIFIED,
                self.tr('Tick if you want a quick (but less accurate) calculation of the SVF'),
                defaultValue = True)) 
        self.addParameter(
            QgsProcessingParameterString(
                self.LOCATION,
                self.tr('A place name to run (recommended: commune name)'),
                defaultValue = "",
                optional = True))
        self.addParameter(
            QgsProcessingParameterExtent(
                self.EXTENT,
                self.tr('Clipping extent'),
                optional = True))
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUTPUT_DIRECTORY,
                self.tr('Directory to save the outputs'),
                defaultValue = ""))

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        
        inputDataset = self.parameterAsInt(parameters, self.INPUT_DATASET, context)
        estimatedHeight = self.parameterAsBoolean(parameters, self.ESTIMATED_HEIGHT, context)
        lczCalc = self.parameterAsBoolean(parameters, self.LCZ_CALC, context)
        utrfCalc = self.parameterAsBoolean(parameters, self.UTRF_CALC, context)
        wrfInputs = self.parameterAsBoolean(parameters, self.WRF_INPUTS, context)
        tebInputs = self.parameterAsBoolean(parameters, self.TEB_INPUTS, context)
        svfSimplified = self.parameterAsBoolean(parameters, self.SVF_SIMPLIFIED, context)
        location = self.parameterAsString(parameters, self.LOCATION, context)
        bbox = self.parameterAsExtent(parameters, self.EXTENT, context)
        bbox_crs_ini = self.parameterAsExtentCrs(parameters, self.EXTENT, context)
        outputDirectory = self.parameterAsString(parameters, self.OUTPUT_DIRECTORY, context)
        
        #prefix = unidecode.unidecode(weatherScenario).replace(" ", "_")
        
        if location and not bbox.isNull():
            raise QgsProcessingException("You should fill a location OR select an extent, not both !!")
        elif not location and bbox.isNull():
            raise QgsProcessingException("You should specify a location or select an extent !!")

        
        # Get the plugin directory to put the last stable GeoClimate version
        plugin_directory = self.plugin_dir = os.path.dirname(__file__)
        
        # GeoClimate path of the last version
        geoclim_jar_path = os.path.join(plugin_directory, 'Resources', GEOCLIMATE_JAR_NAME)
        
        list_loc_geoc_vers = glob.glob(os.path.join(plugin_directory, 'Resources', "geoclimate*.jar"))
        if list_loc_geoc_vers:
            # Remove all potential old GeoClimate versions
            list_old_geoc_vers = list_loc_geoc_vers.copy()
            if list_loc_geoc_vers.count(geoclim_jar_path)>0:
                list_old_geoc_vers.remove(geoclim_jar_path)
            for path_old_v in list_old_geoc_vers:
                os.remove(path_old_v)
            
            # Download the last GeoClimate version if not already downloaded
            if not os.path.exists(geoclim_jar_path):
                if feedback:
                    feedback.setProgressText("You do not have the last GeoClimate version. Downloading...")
                    if feedback.isCanceled():
                        feedback.setProgressText("Calculation cancelled by user")
                        return {}
                urlretrieve(GEOCLIMATE_JAR_URL, geoclim_jar_path)
        else:
            if feedback:
                feedback.setProgressText("You do not have the last GeoClimate version. Downloading...")
                if feedback.isCanceled():
                    feedback.setProgressText("Calculation cancelled by user")
                    return {}
            urlretrieve(GEOCLIMATE_JAR_URL, geoclim_jar_path)
            
        # Get the input dataset used by the workflow
        inputDataset = list(SRID.keys())[inputDataset]
        
        # Recover the bbox coordinates if exists
        if not bbox.isNull():
            # Get the bbox srid
            if not bbox_crs_ini:
                mapRenderer = iface.mapCanvas().mapRenderer()
                bbox_crs_ini=mapRenderer.destinationCrs()
            # Get the srid as an integer
            bbox_srid_ini = bbox_crs_ini.postgisSrid()

            
            # The bbox coordinates should be in the correct srid, otherwise should be reprojected
            if bbox_srid_ini != SRID[inputDataset]:
                bbox_transform = QgsCoordinateTransform(QgsCoordinateReferenceSystem("EPSG:3111"),
                                                        QgsCoordinateReferenceSystem("EPSG:4326"),
                                                        QgsProject.instance())
                # The rectangle has to be converted to geometry before transform...
                bbox_geom = QgsGeometry.fromRect(bbox)
                bbox_geom.transform(bbox_transform)
                # The geometry has to be converted back to rectangle to get x and y min and max...
                bbox = bbox_geom.boundingBox()
            
            # Create the bbox as required by GeoClimate
            bbox_coord = [bbox.xMinimum(),
                          bbox.yMinimum(),
                          bbox.xMaximum(),
                          bbox.yMaximum()]
            
            # The location argument in the GeoClimate config file is replaced by
            # the bbox coordinates
            location = bbox_coord
            
        if feedback:
            feedback.setProgressText("Start GeoClimate calculations")
            if feedback.isCanceled():
                feedback.setProgressText("Calculation cancelled by user")
                return {}
        
        # Create the outputDirectory if not exists
        if not os.path.exists(outputDirectory):
            if os.path.exists(Path(outputDirectory).parent.absolute()):
                os.mkdir(outputDirectory)
            else:
                raise QgsProcessingException('The output directory does not exist, neither its parent directory')
        config_file_path = os.path.join(outputDirectory, 
                                        CONFIG_FILENAME.format(str(location).replace(',','_')))
        
        # Fill in the indicator use list
        estimateHeight = False
        indicatorUse = []
        if lczCalc:
            indicatorUse.append("LCZ")
        if tebInputs:
            indicatorUse.append("TEB")
        if utrfCalc:
            indicatorUse.append("UTRF")
        if wrfInputs:
            indicatorUse.append("WRF")


        # Create the json configuration file used by GeoClimate
        config_file_content = {
            "description": "GeoClimate configuration file created using the QGIS plug-in GeoClimateTool",
            "input": {
                "locations": [
                    location
                ],
                "area": 10000
            },
            "output": {
                "folder": outputDirectory,
                "tables": OUTPUT_TABLES
            },
            "parameters": {
                "rsu_indicators": {
                    "indicatorUse": indicatorUse,
                    "svfSimplified": svfSimplified,
                    "estimateHeight": estimateHeight
                }
            }
        }

        # Serializing json
        json_object = json.dumps(config_file_content, indent=4)
         
        # Writing to sample.json
        with open(config_file_path, "w") as outfile:
            outfile.write(json_object)
        
        # Define the java command line to be executed
        java_cmd = f'java -jar {geoclim_jar_path} -w OSM -f {config_file_path}'
        
        # Execute the GeoClimate workflow and log informations
        for line in runProcess(java_cmd.split()):
            feedback.setProgressText(line.decode("utf8"))
            
        
        # ######################################################################
        # ######################## LOAD DATA INTO QGIS #########################
        # ######################################################################
        # # Calculates the number of significant digits
        # if NB_ISOVALUES < 10:
        #     sign_digits = 1
        # else:
        #     sign_digits = 2
            
        # # Load data into QGIS
        # global layernames
        # layernames = {}
        # i = 0
        # for tp in [DAY_TIME, NIGHT_TIME]:
        #     layernames[i] = Renamer(f"{scenarioDirectory.split(os.sep)[-1]} and {weatherScenario}: Park impact on air temperature at {tp}:00 (°C)")
        #     # Load the vector layer with a given style
        #     loadCoolParksVector(filepath = output_dt_path[tp] + ".geojson",
        #                         layername = layernames[i],
        #                         variable = None,
        #                         subgroup = QgsLayerTreeGroup("parameter not used..."),
        #                         vector_min = deltaT_min_value,
        #                         vector_max = deltaT_max_value,
        #                         feedback = feedback,
        #                         context = context,
        #                         valueZero = 0,
        #                         opacity = DEFAULT_OPACITY)
        #     i += 1
        
        # # Load building results into QGIS
        # for var in BUILDING_LEGEND_PROCESS.index:
        #     layernames[i] = Renamer(f"{scenarioDirectory.split(os.sep)[-1]} and {weatherScenario}: {BUILDING_LEGEND_PROCESS[var]}")
        #     loadCoolParksVector(filepath = output_build_path,
        #                         layername = layernames[i],
        #                         variable = var,
        #                         subgroup = QgsLayerTreeGroup("parameter not used..."),
        #                         vector_min = gdf_build[var].min(),
        #                         vector_max = gdf_build[var].max(),
        #                         feedback = feedback,
        #                         context = context,
        #                         valueZero = 0,
        #                         opacity = 1)
        #     i += 1
        
        # # Return the output file names
        # return {self.OUTPUT_DIRECTORY: scenarioDirectory + os.sep + OUTPUT_PROCESSOR_FOLDER + os.sep + prefix}
        # Return the output file names
        return {self.OUTPUT_DIRECTORY: outputDirectory}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'coolparkstool_process'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('GeoClimate workflow')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
    
    def shortHelpString(self):
        return self.tr('The GeoClimateTool "GeoClimate workflows" module is used '+
                       'to:\n'+
                       '    - download data from OSM and convert to GIS files,\n'+
                       '    - calculates spatial indicators and typology from these files,\n'
        '\n'
        '\n'
        '---------------\n'
        'Full manual available via the <b>Help</b>-button.')

    def helpUrl(self):
        url = "https://github.com/j3r3m1/geoclimatetool"
        return url
    
    def icon(self):
        cmd_folder = Path(os.path.split(inspect.getfile(inspect.currentframe()))[0]).parent
        icon = QIcon(str(cmd_folder) + "/icons/CoolParksTool.png")
        return icon

    def createInstance(self):
        return GeoClimateProcessorAlgorithm()
